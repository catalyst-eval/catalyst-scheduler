// src/lib/util/service-initializer.ts

import { logger } from './logger';
import { runSheetVerification } from './sheet-verification';
import { ErrorRecoveryService, OperationType } from './error-recovery';
import { RowMonitorService, verifyAppointmentDeletion } from './row-monitor';
import { IGoogleSheetsService } from '../google/sheets';

/**
 * Initialize all utility services
 * This provides a single point to start up all the enhancement services
 */
export async function initializeServices(sheetsService: IGoogleSheetsService): Promise<{
  errorRecovery: ErrorRecoveryService;
  rowMonitor: RowMonitorService;
}> {
  logger.info('Initializing enhanced services');
  
  // Create services
  const errorRecovery = new ErrorRecoveryService(sheetsService);
  const rowMonitor = new RowMonitorService(sheetsService);
  
  try {
    // Run sheet verification at startup
    logger.info('Running sheet structure verification');
    const verificationResult = await runSheetVerification();
    
    if (!verificationResult.verified) {
      logger.warn('Sheet structure verification failed - see logs for details');
    }
    
    // Start error recovery service
    logger.info('Starting error recovery service');
    errorRecovery.startRecovery();
    
    // Start row monitoring service
    logger.info('Starting row monitoring service');
    rowMonitor.startMonitoring();
    
    logger.info('Enhanced services successfully initialized');
    
    return {
      errorRecovery,
      rowMonitor
    };
  } catch (error) {
    logger.error('Error initializing enhanced services', error);
    throw error;
  }
}

/**
 * Enhanced wrapper for deleteAppointment that includes verification and recovery
 * This demonstrates how to use the new utilities for improved reliability
 */
export async function enhancedDeleteAppointment(
  sheetsService: IGoogleSheetsService,
  errorRecovery: ErrorRecoveryService,
  appointmentId: string
): Promise<boolean> {
  logger.info(`Enhanced delete appointment: ${appointmentId}`);
  
  try {
    // Attempt to delete the appointment
    await sheetsService.deleteAppointment(appointmentId);
    
    // Verify the deletion was successful
    const verified = await verifyAppointmentDeletion(sheetsService, appointmentId);
    
    if (!verified) {
      logger.warn(`Deletion verification failed for appointment ${appointmentId}, recording failed operation`);
      
      // Record the failed operation for later recovery
      errorRecovery.recordFailedOperation(
        OperationType.APPOINTMENT_DELETION,
        { appointmentId },
        'Deletion verification failed'
      );
      
      return false;
    }
    
    logger.info(`Successfully deleted and verified appointment ${appointmentId}`);
    return true;
  } catch (error) {
    logger.error(`Error deleting appointment ${appointmentId}`, error);
    
    // Record the failed operation for later recovery
    errorRecovery.recordFailedOperation(
      OperationType.APPOINTMENT_DELETION,
      { appointmentId },
      error
    );
    
    return false;
  }
}

/**
 * Example of using the enhanced utilities in the appointment cancellation handler
 */
export function exampleUsageInCancellationHandler(): string {
  return `
/**
 * Handle appointment cancellation - With enhanced error recovery
 */
private async handleAppointmentCancellation(
  appointment: IntakeQAppointment
): Promise<WebhookResponse> {
  try {
    logger.info('Processing appointment cancellation:', { appointmentId: appointment.Id });
    
    // 1. Check if appointment exists
    const existingAppointment = await this.sheetsService.getAppointment(appointment.Id);
    
    if (!existingAppointment) {
      return {
        success: false,
        error: \`Appointment \${appointment.Id} not found for cancellation\`,
        retryable: false
      };
    }
    
    try {
      // 2. Use the enhanced delete method for improved reliability
      const success = await enhancedDeleteAppointment(
        this.sheetsService,
        this.errorRecoveryService,
        appointment.Id
      );
      
      if (!success) {
        logger.warn(\`Enhanced delete failed for appointment \${appointment.Id}, attempting fallback\`);
        
        // Fallback to status update
        const cancellationUpdate: AppointmentRecord = {
          ...existingAppointment,
          status: 'cancelled' as 'cancelled',
          lastUpdated: new Date().toISOString(),
          notes: (existingAppointment.notes || '') + 
                 \`\\nCancelled: \${new Date().toISOString()}\` + 
                 (appointment.CancellationReason ? \`\\nReason: \${appointment.CancellationReason}\` : '')
        };
        
        // Update the appointment with cancelled status
        await this.sheetsService.updateAppointment(cancellationUpdate);
        logger.info(\`Fallback successful: Updated appointment \${appointment.Id} status to cancelled\`);
      }
    } catch (error) {
      logger.error(\`Both deletion and status update failed for appointment \${appointment.Id}\`, error);
      throw error;
    }
    
    // 3. Log cancellation
    await this.sheetsService.addAuditLog({
      timestamp: new Date().toISOString(),
      eventType: 'APPOINTMENT_CANCELLED' as AuditEventType,
      description: \`Cancelled appointment \${appointment.Id}\`,
      user: 'SYSTEM',
      systemNotes: JSON.stringify({
        appointmentId: appointment.Id,
        clientId: appointment.ClientId,
        reason: appointment.CancellationReason || 'No reason provided'
      })
    });

    return {
      success: true,
      details: {
        appointmentId: appointment.Id,
        action: 'cancelled_and_processed'
      }
    };
  } catch (error) {
    logger.error('Error handling appointment cancellation:', error);
    
    // Add detailed error logging
    await this.sheetsService.addAuditLog({
      timestamp: new Date().toISOString(),
      eventType: 'SYSTEM_ERROR' as AuditEventType,
      description: \`Error cancelling appointment \${appointment.Id}\`,
      user: 'SYSTEM',
      systemNotes: error instanceof Error ? error.message : 'Unknown error'
    });
    
    throw error;
  }
}
  `;
}